<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>10</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
</head>
<body>
<p><img src="image.png" /></p>
<hr />
<p><img src="image-1.png" /> <span class="math inline">\(✓\)</span></p>
<hr />
<p><img src="image-2.png" /> <span class="math display">\[\text{
PC}_{ws}\left( i,\text{ acc} \right) = \begin{cases}
0 &amp; \text{si }i &lt; 1 \\
\text{ PC}_{ws}\left( i - 1,\text{ acc} \right) &amp; \text{si }i \geq 1
\land s_{i} &lt; \text{ acc} \\
\max\left\{ \text{PC}_{ws}\left( i - 1,\text{ acc} \right),1 +
\text{PC}_{ws}\left( i - 1,\text{ acc} + w_{i} \right) \right\} &amp;
\text{si }i \geq 1 \land s_{i} \geq \text{ acc }
\end{cases}\]</span></p>
<p>Recorremos “de adelante para atrás”</p>
<p>El caso base no suma nada, es solo para definir un final, ya pasamos
todos los <span class="math inline">\(i \in \left\{ 1...N
\right\}\)</span>.</p>
<p>El primer caso recursivo define si superamos el peso que la caja
<span class="math inline">\(i\)</span> puede cargar, luego, no suma nada
y sigue sin tener en cuenta esa caja.</p>
<p>El segundo caso recursivo es el que nos suma <span
class="math inline">\(1\)</span> si <span
class="math inline">\(i\)</span> puede cargarlo, entonces suma <span
class="math inline">\(w_{i}\)</span> al acumulador y continúa la
recursión.</p>
<p>El problema se resuelve con <span
class="math inline">\(\text{PC}_{ws}(N,0)\)</span></p>
<hr />
<p><img src="image-3.png" /></p>
<h2>Top-down</h2>
<p>Primero definimos <span class="math inline">\(\text{acc}_{\max} =
\sum_{i = 1}^{N}w_{i}\)</span>, luego</p>
<pre><code>f solve(w,s,N):- Sea $k$ el resultado, las cajas están apiladas de la forma ${i_1 ... i_k} | i_1 &lt; ... &lt; i_k$
- $ forall j in {1...k-1}: (sum_(t=j+1)^k w_i_t ) &lt;= s_i_j $

  memo = matriz N*acc_max con todo -1 

  f pc(i,acc):
    if i = 0:
      ret 0
      
    if memo[i][acc] &gt;= 0:
      ret memo[i][acc]

    if s[i] &lt; acc:
      memo[i][acc] = pc(i-1,acc)
    if s[i] &gt;= acc:
      memo[i][acc] = max(pc(i-1,acc), pc(i-1,acc+w[i])+1)

    return memo[i][acc]

  ret pc(N,0)
</code></pre>
<p>Su complejidad espacial y temporal están limitadas por la cantidad de
estados, <span class="math inline">\(O\left( N \cdot \sum_{i =
1}^{N}w_{i} \right)\)</span></p>
<h2>Bottom-up</h2>
<pre><code>f solve(w,s,N):

  memo = [-1] de N*acc_max
  for acc en 0...acc_max:
    memo[0][acc] = 0 

  for i in 1...N:
    for acc in acc_max...0:

      if acc+w[i] &lt;= acc_max:
        use = 1 + memo[i-1][acc+w[i]]

      if acc+w[i] &gt; acc_max:
        use = 0

      memo[i][acc] = max(memo[i-1][acc], use)
</code></pre>
<hr />
<p><img src="image-4.png" /></p>
<h2><strong>Tenemos:</strong></h2>
<p><span class="math inline">\(N \in {\mathbb{N}}\)</span> cantidad de
cajas.</p>
<p>Sea <span class="math inline">\(i \in \left\{ 1...N \right\}\)</span>
la notación de la <span class="math inline">\(i\)</span>-ésima caja, hay
2 vectores:</p>
<p><span class="math inline">\(w = \left\{ w_{1}\ldots w_{N}
\right\}\)</span> donde <span class="math inline">\(w_{i} \in
{\mathbb{N}}\)</span> es el peso de la <span
class="math inline">\(i\)</span>-ésima caja.</p>
<p><span class="math inline">\(s = \left\{ s_{1}\ldots s_{N}
\right\}\)</span> donde <span class="math inline">\(s_{i} \in
{\mathbb{N}}\)</span> es el aguante de la <span
class="math inline">\(i\)</span>-ésima caja.</p>
<h2><strong>Nuestro objetivo es encontrar el máximo número de cajas que
podemos apilar tal que:</strong></h2>
<ul>
<li><p>Sea <span class="math inline">\(k\)</span> el resultado, las
cajas están apiladas de la forma <span class="math inline">\(\left\{
i_{1}\ldots i_{k} \right\}~|~i_{1} &lt; \ldots &lt;
i_{k}\)</span></p></li>
<li><p><span class="math display">\[\forall j \in \left\{ 1...k - 1
\right\}:\left( \sum_{t = j + 1}^{k}{w_{i}}_{t} \right) \leq
{s_{i}}_{j}\]</span></p></li>
</ul>
<h2><strong>Queremos ver que <span
class="math inline">\(\text{PC}_{ws}\left( i,\text{acc} \right)\)</span>
es correcta</strong></h2>
<p><span class="math display">\[\text{ PC}_{ws}\left( i,\text{ acc}
\right) = \begin{cases}
0 &amp; \text{si }i &lt; 1 \leftarrow \left\{ B \right\} \\
\text{ PC}_{ws}\left( i - 1,\text{ acc} \right) &amp; \text{si }i \geq 1
\land s_{i} &lt; \text{ acc} \leftarrow \left\{ R1 \right\} \\
\max\left\{ \text{PC}_{ws}\left( i - 1,\text{ acc} \right),1 +
\text{PC}_{ws}\left( i - 1,\text{ acc} + w_{i} \right) \right\} &amp;
\text{si }i \geq 1 \land s_{i} \geq \text{ acc} \leftarrow \left\{ R2
\right\}
\end{cases}\]</span></p>
<p>Donde <span class="math inline">\(i\)</span> es la caja actual y acc
es el peso acumulado de las cajas sobre <span
class="math inline">\(i\)</span></p>
<h2><strong>Vamos a demostrarlo por inducción en <span
class="math inline">\(i\)</span></strong></h2>
<p><strong>Caso base: <span class="math inline">\(i &lt;
1\)</span></strong></p>
<p>Tenemos 0 cajas</p>
<p><span class="math inline">\(\text{PC}_{ws}\left( 0,\text{ acc}
\right)\underset{\left\{ B \right\}}{=}0\)</span></p>
<p><strong>Paso inductivo:</strong></p>
<p><strong>HI:</strong> Existe un <span class="math inline">\(i =
k\)</span> tal que <span class="math inline">\(\text{PC}_{ws}\left( k -
1,\text{ acc} \right)\)</span> es el máximo de cajas apilables hasta la
<span class="math inline">\(k\)</span>-ésima caja</p>
<p><strong>Queremos ver que <span class="math inline">\(\forall\text{
acc } \in {\mathbb{N}}.\text{ PC}_{ws}\left( k,\text{ acc}
\right)\)</span></strong></p>
<p><strong>Caso R1: <span class="math inline">\(s_{k} &lt; \text{
acc}\)</span></strong></p>
<p>Si <span class="math inline">\(s_{k} &lt; \text{ acc}\)</span> no
puedo apilar las cajas acumuladas sobre <span
class="math inline">\(k\)</span>, por lo que no sumamos nada y seguimos
a la siguiente caja.</p>
<p><span class="math inline">\(\text{PC}_{ws}\left( k,\text{ acc}
\right) = \text{ PC}_{ws}\left( k - 1,\text{ acc}
\right)\underset{\text{HI }}{=}V\)</span></p>
<p><strong>Caso R2 <span class="math inline">\(s_{k} \geq \text{
acc}\)</span></strong></p>
<p><strong>subcaso 1, no apilamos <span
class="math inline">\(k\)</span>:</strong></p>
<p>Mantenemos el mismo número de cajas apiladas como en el caso
<strong>R1</strong></p>
<p><span class="math inline">\(\text{PC}_{ws}\left( k,\text{ acc}
\right) = \text{ PC}_{ws}\left( k - 1,\text{ acc} \right) = \
S1\)</span></p>
<p><strong>subcaso 2, apilamos <span
class="math inline">\(k\)</span>:</strong></p>
<p>Apilamos la <span class="math inline">\(k\)</span>-ésima caja</p>
<p><span class="math inline">\(\text{PC}_{ws}\left( k,\text{ acc}
\right) = \text{ PC}_{ws}\left( k - 1,\text{ acc} + w_{k} \right) + 1 =
\ S2\)</span></p>
<p><strong>Justificación</strong></p>
<p>R2 devuelve el máximo entre S1 y S2, por HI sabemos que hasta <span
class="math inline">\(k - 1\)</span> teníamos el máximo acumulable, se
evalúan todas las chances, para todo <span
class="math inline">\(k\)</span>. Luego <span
class="math inline">\(\text{PC}\left( k,\text{acc} \right)\)</span>
computa máximo número de cajas apiladas hasta la <span
class="math inline">\(k\)</span>-ésima caja.</p>
<p><span class="math inline">\(⬜\)</span></p>
</body>
</html>
